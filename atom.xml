<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://dayuebai.github.io</id>
    <title>Dayue&apos;s Blog</title>
    <updated>2020-11-02T06:47:03.535Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://dayuebai.github.io"/>
    <link rel="self" href="https://dayuebai.github.io/atom.xml"/>
    <subtitle>Stay hungry. Stay foolish.</subtitle>
    <logo>https://dayuebai.github.io/images/avatar.png</logo>
    <icon>https://dayuebai.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Dayue&apos;s Blog</rights>
    <entry>
        <title type="html"><![CDATA[A Probability Question (Solved on 11/01/2020)]]></title>
        <id>https://dayuebai.github.io/post/probability-question/</id>
        <link href="https://dayuebai.github.io/post/probability-question/">
        </link>
        <updated>2020-11-01T10:20:13.000Z</updated>
        <content type="html"><![CDATA[<p>There are 15 apples in total. 4 apples go bad and the others are all fresh apples. Calculate the probability that: we picked the last bad apple at exactly the 9th pick.</p>
<p>Solution:</p>
<p>Assume that all of the apples are different.<br>
Event Q: we picked the last bad apple at exactly the 9th pick.</p>
<p>P(Q) = #(3 bad apples are picked within first 8 picks and the 9th pick is also a bad apple) / sample space</p>
<p>sample space = #(possible order of 15 apples) = 15!</p>
<p>P(Q) = C(8, 3) * P(4, 4) * P(11, 11) / 15! = 8 / 195</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Notes on Mutual Exclusion]]></title>
        <id>https://dayuebai.github.io/post/notes-on-mutual-exclusion/</id>
        <link href="https://dayuebai.github.io/post/notes-on-mutual-exclusion/">
        </link>
        <updated>2020-11-01T05:59:04.000Z</updated>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode 3. Longest Substring Without Repeatable Characters [MEDIUM]]]></title>
        <id>https://dayuebai.github.io/post/leetcode-3-longest-substring-without-repeatable-characters-medium/</id>
        <link href="https://dayuebai.github.io/post/leetcode-3-longest-substring-without-repeatable-characters-medium/">
        </link>
        <updated>2020-11-01T02:07:12.000Z</updated>
        <content type="html"><![CDATA[<pre><code>Given a string s, find the length of the longest substring without repeating characters.


Example 1:

Input: s = &quot;abcabcbb&quot;
Output: 3
Explanation: The answer is &quot;abc&quot;, with the length of 3.
Example 2:

Input: s = &quot;bbbbb&quot;
Output: 1
Explanation: The answer is &quot;b&quot;, with the length of 1.
Example 3:

Input: s = &quot;pwwkew&quot;
Output: 3
Explanation: The answer is &quot;wke&quot;, with the length of 3.
Notice that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring.
Example 4:

Input: s = &quot;&quot;
Output: 0
 

Constraints:

0 &lt;= s.length &lt;= 5 * 104
s consists of English letters, digits, symbols and spaces.
</code></pre>
<h2 id="solution-1-brute-force">Solution 1 (Brute force)</h2>
<p>To find longest substring without repeatable characters, the most naive solution is to<br>
1. first enumerate all possbile substrings<br>
2. check each substring if there exists repeatable characters in the substring.</p>
<p>Step 1 takes O(N^2) time to enumerate all substrings.<br>
Step 2 takes O(N) time check if a substring contains repeatable chracters with hashtable.</p>
<p>Overall, this naive solution takes O(N^3) time.</p>
<h2 id="solution-2-optimized-brute-force">Solution 2 (Optimized brute force)</h2>
<p>We can optimize our solution based on solution 1. For each starting index i, find the maximum value of starting j such that there are no repeatable characters within the range [i, j); when we find the first repeatable characters, stop executing and increment i. In this way, for eaching starting index i, we don't have to iterate j to the last character of the string. Instead, we can stop iterating j when we first find repeatable chracters (further iteration is redundant).</p>
<p>Java code:</p>
<pre><code>Optimized brute force solution
// Time: O(N^2)
// Space: O(128)
// class Solution {
//     public int lengthOfLongestSubstring(String s) {
//         int ans = 0;
        
//         for (int i = 0; i &lt; s.length(); i++) {
//             char[] seen = new char[128];
//             int j = i;
//             while (j &lt; s.length() &amp;&amp; seen[s.charAt(j)] == 0) {
//                 seen[s.charAt(j)] = 1;
//                 j++;
//             }
//             ans = Math.max(ans, j - i);
//         }
        
//         return ans;
//     }
// }
</code></pre>
<p>Analysis:<br>
1. Time<br>
There are N iterations in total (for loop). For each iteration, it loops at most 128 times because there are only 128 unique chracters in ascii table. Therefore the time complexity is O(N^2) =&gt; further reduced to O(N * 128)<br>
2. Space<br>
For each iteration, we keep track of characters that already appear in this iteration. We use an array to check (instead of hashtable, reason: array is cheap, hashtable is expensive). Overall, the space complexity is just the size of the tracking array =&gt; O(128)</p>
<h2 id="solution-3-hash-table-sliding-window">Solution 3 (Hash Table + Sliding Window)</h2>
<p>To further optimize this algorithm, we should think about how we can get the final answer using only one scan of the string. Suppose we have a sliding window [i, j] such that there are no repeatable chracters in the window. Then, the final answer is the maximum possible size of this sliding window.</p>
<p>How to maintain such a window?</p>
<ol>
<li>We keep iterating the ending point (j) of this sliding window. j monotonically increases.</li>
<li>Find the smallest possible value of i.</li>
</ol>
<p>Now, the key challenge is how to find the feasible i for each j?</p>
<ol>
<li>We use a hash table to store the last index of each character.</li>
<li>For an endpoint j (stores character c), find the last index of c (i_c). i should be i_c + 1</li>
</ol>
<p>However, there might be a case shown as below:<br>
<code>abba</code></p>
<p>for j = 3 (zero based), it find the last index of <code>a</code> is 0, so it set i = 0 + 1 = 1. However, the window[1, 3] still contains repeatable chracters.</p>
<p>How to solve this issue?<br>
Let i = Math.max(i, last occurrence index of c + 1) // TODO: need further explanation</p>
<p>Java code:</p>
<pre><code>class Solution {
    public int lengthOfLongestSubstring(String s) {
        int[] lastOccur = new int[128];
        Arrays.fill(lastOccur, -1);
        int ans = 0;
        
        for (int i = 0, j = 0; j &lt; s.length(); j++) {
            i = Math.max(i, lastOccur[s.charAt(j)] + 1);
            ans = Math.max(ans, j - i + 1);
            lastOccur[s.charAt(j)] = j;
        }
        
        return ans;
    }
}
</code></pre>
<p>Analysis:<br>
1. Time: O(N), reason: one time scan of the input array<br>
2. Space: O(128), reason: use array of size 128 as a hash table.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[About]]></title>
        <id>https://dayuebai.github.io/post/about/</id>
        <link href="https://dayuebai.github.io/post/about/">
        </link>
        <updated>2019-01-23T17:09:48.000Z</updated>
    </entry>
</feed>